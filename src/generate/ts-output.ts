import * as pg from "pg";

import { enumDataForSchema, enumTypesForEnumData } from "./enums";
import { header } from "./header";
import { relationsInSchema, definitionForRelationInSchema, crossTableTypesForTables, crossSchemaTypesForAllTables, crossSchemaTypesForSchemas, type Relation } from "./tables";
import type { CompleteConfig } from "./config";
import type { SchemaVersionCanary } from "../db/canary";

export interface CustomTypes {
  [name: string]: string; // any, or TS type for domain's base type
}

const canaryVersion: SchemaVersionCanary["version"] = 104;
const versionCanary = `
  // got a type error on schemaVersionCanary below? update by running \`npx @codeandmoney/dorjo\`
  export interface schemaVersionCanary extends db.SchemaVersionCanary { version: ${canaryVersion} };`;

const declareModule = (module: string, declarations: string) => `
declare module '${module}' {
  ${declarations.replace(/^(?=[ \t]*\S)/gm, "  ")}
}
`;

const customTypeHeader = `/*
** Please edit this file as needed **
It's been generated by Dorjo as a custom type definition placeholder, and won't be overwritten
*/
`;

function sourceFilesForCustomTypes(customTypes: CustomTypes) {
  return Object.fromEntries(
    Object.entries(customTypes).map(([name, baseType]) => [
      name,
      customTypeHeader +
        declareModule(
          "dorjo/custom",
          `${baseType === "db.JsonValue" ? `import type * as db from 'dorjo/db';\n` : ``}export type ${name} = ${baseType};  // replace with your custom type or interface as desired`,
        ),
    ]),
  );
}

function indentAll(level: number, s: string) {
  if (level === 0) {
    return s;
  }
  return s.replace(/^/gm, " ".repeat(level));
}

export const tsForConfig = async (config: CompleteConfig, debug: (s: string) => void) => {
  let querySeq = 0;
  const { schemas, db } = config;
  const pool = new pg.Pool(db);
  const customTypes = {};
  const schemaNames = Object.keys(schemas);

  const queryFn = async (query: pg.QueryConfig, seq = querySeq++) => {
    try {
      debug(`>>> query ${seq} >>>\n${query.text.replace(/^\s+|\s+$/gm, "")}\n+ ${JSON.stringify(query.values)}\n`);
      const result = await pool.query(query);
      debug(`<<< result ${seq} <<<\n${JSON.stringify(result, null, 2)}\n`);
      return result;
    } catch (e) {
      console.log(`*** error ${seq} ***`, e);
      process.exit(1);
    }
  };

  const schemaData = await Promise.all(
    schemaNames.map(async (schema) => {
      const rules = schemas[schema];
      const tables =
        rules?.exclude === "*"
          ? []
          : // exclude takes precedence
            (await relationsInSchema(schema, queryFn))
              .filter((rel) => rules?.include === "*" || rules?.include?.indexOf(rel.name)! >= 0)
              .filter((rel) => rules?.exclude.indexOf(rel.name)! < 0);
      const enums = await enumDataForSchema(schema, queryFn);
      const tableDefs = await Promise.all(tables.map(async (table) => definitionForRelationInSchema(table, schema, enums, customTypes, config, queryFn)));
      const schemaIsUnprefixed = schema === config.unprefixedSchema;
      const none = "/* (none) */";
      const schemaDef =
        `/* === schema: ${schema} === */\n` +
        (schemaIsUnprefixed ? "" : `\nexport namespace ${schema} {\n`) +
        indentAll(
          schemaIsUnprefixed ? 0 : 2,
          `\n/* --- enums --- */\n` +
            (enumTypesForEnumData(enums) || none) +
            `\n\n/* --- tables --- */\n` +
            (tableDefs.join("\n") || none) +
            `\n\n/* --- aggregate types --- */\n` +
            (schemaIsUnprefixed ? `\nexport namespace ${schema} {${indentAll(2, crossTableTypesForTables(tables) || none)}\n}\n` : crossTableTypesForTables(tables) || none),
        ) +
        "\n" +
        (schemaIsUnprefixed ? "" : `}\n`);

      return { schemaDef, tables };
    }),
  );

  const schemaDefs = schemaData.map((r) => r.schemaDef);
  const schemaTables = schemaData.map((r) => r.tables);
  const allTables = ([] as Relation[]).concat(...schemaTables);
  const hasCustomTypes = Object.keys(customTypes).length > 0;

  const content = [
    `import type * as db from '@codeandmoney/dorjo/db';`,
    versionCanary,
    hasCustomTypes ? `import type * as c from '@codeandmoney/dorjo/custom';` : ``,
    schemaDefs.join("\n\n"),
    `/* === global aggregate types === */`,
    crossSchemaTypesForSchemas(schemaNames),
    `/* === lookups === */`,
    crossSchemaTypesForAllTables(allTables, config.unprefixedSchema),
  ].join("\n\n");

  const ts = `
  ${header()}
  
  ${declareModule("@codeandmoney/dorjo/schema", content)}
  `;

  const customTypeSourceFiles = sourceFilesForCustomTypes(customTypes);

  await pool.end();

  return { ts, customTypeSourceFiles };
};
